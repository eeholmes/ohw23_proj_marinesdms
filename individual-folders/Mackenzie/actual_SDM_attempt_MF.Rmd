---
title: "actual SDM attempt"
output: html_document
date: "2023-08-10"
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(maxnet)
library(dplyr)
library(maxnet)
library(sf)
library(stars)
library(geodata)
library(dismo)
library(lubridate)
library(sdmpredictors)
library(zoon)
```

# Pre-SDM

## Load data in

```{r}
pts.abs <- read.csv("/home/jovyan/R/ohw23_proj_marinesdms/data/raw-bio/pts_absence.csv") # X is lon and Y is lat

io.turtles <- read.csv("/home/jovyan/R/ohw23_proj_marinesdms/data/raw-bio/io-sea-turtles.csv") 
```

## Format occurrence data

```{r}
spp <- c("Chelonia mydas", "Caretta caretta", "Eretmochelys imbricata", "Lepidochelys olivacea", "Natator depressus", "Dermochelys coriacea") # turtle species we're interested in

occ <- io.turtles %>% 
  subset(scientificName == spp) # subsetting all the occurence data to just those turtles 

table(occ$scientificName) # seeing how often each species occurs

occ <- occ %>% # but we also need to subset the occurences to include just those in the water (not the ones on land)
  subset(bathymetry > 0 & 
                        shoredistance > 0 & 
                        coordinateUncertaintyInMeters < 200)

table(occ$scientificName) # seeing how often each species occurs now
# Caretta caretta is Loggerhead and Chelonia mydas is Green sea turtles 

occ.sub <- occ[,c(2,4,5,6,9,11,13,14)] # choosing the cols I want

occ.sub$eventDate <- lubridate::ymd_hms(occ.sub$eventDate) # changing to datetime format

colnames(occ.sub) <- c("sci.name", "obsv.datetime", "lat", "lon", "life.stage", "bathy", "SST", "SSS") # renaming
```

```{r}
# format background/absence points

colnames(pts.abs) <- c("lon","lat")

abs.points <- sf::st_as_sf(pts.abs, coords = c("lon", "lat"), crs = 4326)
```

```{r}
# format prescence/occurrence points

occ.points <- sf::st_as_sf(occ.sub, coords = c("lon", "lat"), crs = 4326)
occ.points
```

## Pull in background data

```{r}
env.back <- stars::st_extract(env.stars, sf::st_coordinates(abs.points)) %>% 
  dplyr::as_tibble() %>% 
  na.omit()
env.back
```

## SDM predictors

### Loading in

```{r}
datasets <- sdmpredictors::list_datasets(terrestrial = FALSE, marine = TRUE)
View(datasets)

layers <- list_layers(datasets)
View(layers)
```

### Choosing and formatting

```{r}
#layercodes <- c("BO_sstmean", "BO_bathymin", "BO_bathymax", "BO_bathymean", "BO2_chlomax_bdmean", "BO2_dissoxmin_bdmean", "BO2_dissoxmean_bdmean", "BO2_dissoxrange_bdmean", "BO2_nitratemean_bdmean", "BO2_phosphatemean_bdmean", "BO2_tempmean_bdmean", "BO2_temprange_bdmean", "BO2_salinitymean_bdmean", "BO2_salinityrange_bdmean", "BO2_tempmean_ss", "BO2_temprange_ss", "BO2_chlomean_ss") # my first go around with lots of env variables (hint this takes FORever)

layercodes = c("BO_sstmean", "BO_bathymean", "BO22_ph", "BO2_dissoxmean_bdmean", "BO2_salinitymean_ss") # the env variables I chose from SDMpredictors

env <- load_layers(layercodes, rasterstack = T) # take out the equalarea arg or you will be sad AND add rasterstack = T
env.stars <- stars::st_as_stars(env) # convert to stars object
env.stars <- split(env.stars)
env.obs <- stars::st_extract(env.stars,
                             sf::st_coordinates(occ.points)) %>%
  dplyr::as_tibble()

lats <- c(-0.125, 32.125); lons <- c(41.875, 70.125) # IO lat/lon range
# raster extent is defined by west lon, east lon, south lat, north lat
ext <- raster::extent(lons[1], lons[2], lats[1], lats[2])
extent_polygon <- as(ext, "SpatialPolygons") %>% 
  st_as_sf()
# we need to assign a coordinate system; 4326 is the default for maps in sf
sf::st_crs(extent_polygon) <- 4326 # applying a coordinate system

plot(extent_polygon) # look a rectangle

io.rast <- raster::crop(env, extent(extent_polygon))
plot(io.rast) # look NOT a rectangle- your env variables cropped to the Indian Ocean!
```

```{r}
# ignore for now

# points <- SpatialPoints(occ[,c("decimalLongitude", "decimalLatitude")],
#                             lonlatproj)
# workflow(
#   occurrence = LocalOccurrenceData(
#       points, occurrenceType="presence",
#       columns = c("decimalLongitude", "decimalLatitude", "value")), 
#     covariate = LocalRaster(stack(australia)),
#     process = OneHundredBackground(seed = 42),
#     model = LogisticRegression,
#     output = PrintMap)
```

## Combining env and occ data ?????

```{r}
poly <- occ.points %>%                                 # start with obs
  sf::st_combine() %>%                          # combine into a single multipoint
  sf::st_convex_hull() %>%                      # find convex hull
  sf::st_transform(crs = sf::st_crs(5880)) %>%  # make planar
  #sf::st_buffer(dist = 200000) |>             # buffer by 200000m
  sf::st_transform(crs = sf::st_crs(4326))    # make spherical
```

```{r}
# N <- 1200
# back <- sf::st_sample(poly, N)
# 
# env_back <- stars::st_extract(recent, sf::st_coordinates(back)) |>
#   dplyr::as_tibble() |>
#   na.omit()
# env_back

plot.new()

col <- sf.colors(categorical = TRUE)
bb <- sf::st_bbox(extent_polygon)
# plot(io.rast %>%  
#        sf::st_crop(bb), 
#      main = "", axes = TRUE, key.pos = NULL, reset = FALSE)
# maps::map('world', add = TRUE, lwd = 2)
# plot(sf::st_geometry(occ.points), col = col[4], pch = 16, add = TRUE)
#plot(sf::st_geometry(poly), add = TRUE, border = col[5], lwd = 2)
#plot(back, add = TRUE, col = col[8], pch = ".")
```

# SDM Model

## Running model

```{r}
env.obs <- na.omit(env.obs); env.back <- na.omit(env.back) # remove NA values

pres <- c(rep(1, nrow(env.obs)), rep(0, nrow(env.back))) # create values of 1 for presence data and 0 for absence data

sdm.model <- maxnet::maxnet(pres, rbind(env.obs, env.back))
```

## Model metrics

```{r}
responses <- plot(sdm.model, type = "cloglog")
```

## Predicting

```{r}
clamp <- TRUE       # see ?predict.maxnet for details
type <- "cloglog"
predicted <- predict(sdm.model, env.stars %>% sf::st_crop(bb), clamp = clamp, type = type)
predicted
```

